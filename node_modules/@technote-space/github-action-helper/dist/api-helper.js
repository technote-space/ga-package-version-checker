"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const core_1 = require("@actions/core");
const utils_1 = require("./utils");
/**
 * API Helper
 */
class ApiHelper {
    /**
     * @param {Logger} logger logger
     * @param {object} options options
     * @param {string|undefined} options.branch branch
     * @param {string|undefined} options.sender sender
     * @param {string|undefined} options.refForUpdate ref for update
     * @param {boolean|undefined} options.suppressBPError suppress branch protection error?
     */
    constructor(logger, options) {
        this.logger = logger;
        this.branch = undefined;
        this.sender = undefined;
        this.suppressBPError = undefined;
        this.refForUpdate = undefined;
        this.prCache = {};
        /**
         * @param {Context} context context
         * @return {string|boolean} sender
         */
        this.getSender = (context) => this.sender ? this.sender : utils_1.getSender(context);
        /**
         * @param {boolean} encode encode?
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {string} ref for update
         */
        this.getRefForUpdate = (encode, octokit, context) => __awaiter(this, void 0, void 0, function* () {
            const ref = this.refForUpdate ? this.refForUpdate : (utils_1.isPrRef(context) ? ('heads/' + (yield this.getPR(octokit, context)).data.head.ref) : utils_1.getRefForUpdate(context));
            return encode ? encodeURIComponent(ref) : ref;
        });
        /**
         * @param {string} rootDir root dir
         * @param {string} filepath filepath
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<{ path: string, sha: string }>} blob
         */
        this.createBlob = (rootDir, filepath, octokit, context) => __awaiter(this, void 0, void 0, function* () {
            const blob = yield octokit.git.createBlob({
                owner: context.repo.owner,
                repo: context.repo.repo,
                content: Buffer.from(fs_1.default.readFileSync(path_1.default.resolve(rootDir, filepath), 'utf8')).toString('base64'),
                encoding: 'base64',
            });
            return {
                path: filepath,
                sha: blob.data.sha,
            };
        });
        /**
         * @param {Context} context context
         * @return {string} commit sha
         */
        this.getCommitSha = (context) => utils_1.isPrRef(context) ? context.payload.after : context.sha;
        /**
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<Response<GitGetCommitResponse>>} commit
         */
        this.getCommit = (octokit, context) => __awaiter(this, void 0, void 0, function* () {
            return octokit.git.getCommit({
                owner: context.repo.owner,
                repo: context.repo.repo,
                'commit_sha': this.getCommitSha(context),
            });
        });
        /**
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<Response<PullsGetResponse>>} commit
         */
        this.getPR = (octokit, context) => __awaiter(this, void 0, void 0, function* () {
            const key = parseInt(context.payload.number, 10);
            if (!(key in this.prCache)) {
                this.prCache[key] = yield octokit.pulls.get({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    'pull_number': context.payload.number,
                });
            }
            return this.prCache[key];
        });
        /**
         * @param {string} rootDir root dir
         * @param {object} files files
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<{ path: string, sha: string }[]>} blobs
         */
        this.filesToBlobs = (rootDir, files, octokit, context) => __awaiter(this, void 0, void 0, function* () { return yield Promise.all(Object.values(files).map(file => this.createBlob(rootDir, file, octokit, context))); });
        /**
         * @param {{ path: string, sha: string }[]} blobs blobs
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<Response<GitCreateTreeResponse>>} tree
         */
        this.createTree = (blobs, octokit, context) => __awaiter(this, void 0, void 0, function* () {
            return octokit.git.createTree({
                owner: context.repo.owner,
                repo: context.repo.repo,
                'base_tree': (yield this.getCommit(octokit, context)).data.tree.sha,
                tree: Object.values(blobs).map(blob => ({
                    path: blob.path,
                    type: 'blob',
                    mode: '100644',
                    sha: blob.sha,
                })),
            });
        });
        /**
         * @param {string} commitMessage commit message
         * @param {Response<GitCreateTreeResponse>} tree tree
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<Response<GitCreateCommitResponse>>} commit
         */
        this.createCommit = (commitMessage, tree, octokit, context) => __awaiter(this, void 0, void 0, function* () {
            return octokit.git.createCommit({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tree: tree.data.sha,
                parents: [this.getCommitSha(context)],
                message: commitMessage,
            });
        });
        /**
         * @param {string} refName refName
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<AnyResponse|null>} refName
         */
        this.getRef = (refName, octokit, context) => __awaiter(this, void 0, void 0, function* () {
            try {
                return yield octokit.git.getRef({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: refName,
                });
            }
            catch (error) {
                return null;
            }
        });
        /**
         * @param {Response<GitCreateCommitResponse>} commit commit
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<void>} void
         */
        this.updateRef = (commit, octokit, context) => __awaiter(this, void 0, void 0, function* () {
            try {
                yield octokit.git.updateRef({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: yield this.getRefForUpdate(true, octokit, context),
                    sha: commit.data.sha,
                });
                return true;
            }
            catch (error) {
                if (this.suppressBPError === true && this.isProtectedBranchError(error)) {
                    this.logger.warn('Branch is protected.');
                }
                else {
                    throw error;
                }
                return false;
            }
        });
        /**
         * @param {Response<GitCreateCommitResponse>} commit commit
         * @param {string} refName refName
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<void>} void
         */
        this.createRef = (commit, refName, octokit, context) => __awaiter(this, void 0, void 0, function* () {
            yield octokit.git.createRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: refName,
                sha: commit.data.sha,
            });
        });
        /**
         * @param {string} branchName branch name
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<Response<PullsListResponse>>} pulls
         */
        this.pullsList = (branchName, octokit, context) => __awaiter(this, void 0, void 0, function* () {
            return octokit.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head: `${context.repo.owner}:${branchName}`,
            });
        });
        /**
         * @param {string} branchName branch name
         * @param {PullsCreateParams} detail detail
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<PullsCreateResponse>} pull
         */
        this.pullsCreate = (branchName, detail, octokit, context) => __awaiter(this, void 0, void 0, function* () {
            return octokit.pulls.create(Object.assign({ owner: context.repo.owner, repo: context.repo.repo, head: `${context.repo.owner}:${branchName}`, base: (yield this.getRefForUpdate(false, octokit, context)).replace(/^heads\//, '') }, detail));
        });
        /**
         * @param {number} number pull number
         * @param {PullsCreateParams} detail detail
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<PullsUpdateResponse>} pull
         */
        this.pullsUpdate = (number, detail, octokit, context) => __awaiter(this, void 0, void 0, function* () {
            return octokit.pulls.update(Object.assign({ owner: context.repo.owner, repo: context.repo.repo, 'pull_number': number, base: (yield this.getRefForUpdate(false, octokit, context)).replace(/^heads\//, ''), state: 'open' }, detail));
        });
        /**
         * @param {Error} error error
         * @return {boolean} result
         */
        this.isProtectedBranchError = (error) => /required status checks?.* (is|are) expected/i.test(error.message);
        /**
         * @param {string[]} files files
         * @return {boolean} diff?
         */
        this.checkDiff = (files) => {
            if (!files.length) {
                this.logger.info('There is no diff.');
                return false;
            }
            return true;
        };
        /**
         * @param {string} rootDir root dir
         * @param {string} commitMessage commit message
         * @param {string[]} files files
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<Response<GitCreateCommitResponse>>} commit
         */
        this.prepareCommit = (rootDir, commitMessage, files, octokit, context) => __awaiter(this, void 0, void 0, function* () {
            this.logger.startProcess('Creating blobs...');
            const blobs = yield this.filesToBlobs(rootDir, files, octokit, context);
            this.logger.startProcess('Creating tree...');
            const tree = yield this.createTree(blobs, octokit, context);
            this.logger.startProcess('Creating commit... [%s]', tree.data.sha);
            return this.createCommit(commitMessage, tree, octokit, context);
        });
        /**
         * @param {string} rootDir root dir
         * @param {string} commitMessage commit message
         * @param {string[]} files files
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<boolean>} result
         */
        this.commit = (rootDir, commitMessage, files, octokit, context) => __awaiter(this, void 0, void 0, function* () {
            if (!this.checkDiff(files)) {
                return false;
            }
            const commit = yield this.prepareCommit(rootDir, commitMessage, files, octokit, context);
            this.logger.startProcess('Updating ref... [%s] [%s]', yield this.getRefForUpdate(true, octokit, context), commit.data.sha);
            if (yield this.updateRef(commit, octokit, context)) {
                process.env.GITHUB_SHA = commit.data.sha;
                core_1.exportVariable('GITHUB_SHA', commit.data.sha);
            }
            this.logger.endProcess();
            return true;
        });
        /**
         * @param {string} rootDir root dir
         * @param {string} commitMessage commit message
         * @param {string[]} files files
         * @param {string} createBranchName branch name
         * @param {PullsCreateParams} detail detail
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<boolean>} result
         */
        this.createPR = (rootDir, commitMessage, files, createBranchName, detail, octokit, context) => __awaiter(this, void 0, void 0, function* () {
            if (!this.checkDiff(files)) {
                return false;
            }
            const branchName = createBranchName.replace(/^(refs\/)?heads/, '');
            const headName = `heads/${branchName}`;
            const refName = `refs/${headName}`;
            const commit = yield this.prepareCommit(rootDir, commitMessage, files, octokit, context);
            this.logger.startProcess('Creating reference... [%s] [%s]', refName, commit.data.sha);
            const ref = yield this.getRef(headName, octokit, context);
            if (null === ref) {
                yield this.createRef(commit, refName, octokit, context);
            }
            this.logger.startProcess('Creating PullRequest... [%s] -> [%s]', branchName, yield this.getRefForUpdate(false, octokit, context));
            const pulls = yield this.pullsList(branchName, octokit, context);
            if (pulls.data.length) {
                yield this.pullsUpdate(pulls.data[0].number, detail, octokit, context);
            }
            else {
                yield this.pullsCreate(branchName, detail, octokit, context);
            }
            this.logger.endProcess();
            return true;
        });
        /**
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<{ login: string, email: string, name: string, id: number }>} user
         */
        this.getUser = (octokit, context) => __awaiter(this, void 0, void 0, function* () {
            const sender = this.getSender(context);
            if (false === sender) {
                throw new Error('Sender is not valid.');
            }
            const { data: user } = yield octokit.users.getByUsername({
                username: sender,
            });
            return {
                login: user.login,
                email: user.email,
                name: user.name,
                id: user.id,
            };
        });
        if (options) {
            this.branch = options.branch;
            this.sender = options.sender;
            this.refForUpdate = options.refForUpdate;
            this.suppressBPError = options.suppressBPError;
        }
    }
}
exports.default = ApiHelper;
//# sourceMappingURL=api-helper.js.map