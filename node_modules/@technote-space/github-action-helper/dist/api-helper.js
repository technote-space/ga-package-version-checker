"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const core_1 = require("@actions/core");
const utils_1 = require("./utils");
const context_helper_1 = require("./context-helper");
/**
 * API Helper
 */
class ApiHelper {
    /**
     * @param {Logger} logger logger
     * @param {object} options options
     * @param {string|undefined} options.branch branch
     * @param {string|undefined} options.sender sender
     * @param {string|undefined} options.refForUpdate ref for update
     * @param {boolean|undefined} options.suppressBPError suppress branch protection error?
     */
    constructor(logger, options) {
        this.logger = logger;
        this.branch = undefined;
        this.sender = undefined;
        this.suppressBPError = undefined;
        this.refForUpdate = undefined;
        this.prCache = {};
        /**
         * @param {Context} context context
         * @return {string|boolean} sender
         */
        this.getSender = (context) => this.sender ? this.sender : context_helper_1.getSender(context);
        /**
         * @param {boolean} encode encode?
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {string} ref for update
         */
        this.getRefForUpdate = (encode, octokit, context) => __awaiter(this, void 0, void 0, function* () {
            const ref = this.refForUpdate ? this.refForUpdate : (utils_1.isPrRef(context) ? ('heads/' + (yield this.getPR(octokit, context)).data.head.ref) : utils_1.getRefForUpdate(context));
            return encode ? encodeURIComponent(ref) : ref;
        });
        /**
         * @param {string} rootDir root dir
         * @param {string} filepath filepath
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<{ path: string, sha: string }>} blob
         */
        this.createBlob = (rootDir, filepath, octokit, context) => __awaiter(this, void 0, void 0, function* () {
            const blob = yield octokit.git.createBlob({
                owner: context.repo.owner,
                repo: context.repo.repo,
                content: Buffer.from(fs_1.default.readFileSync(path_1.default.resolve(rootDir, filepath), 'utf8')).toString('base64'),
                encoding: 'base64',
            });
            return {
                path: filepath,
                sha: blob.data.sha,
            };
        });
        /**
         * @param {Context} context context
         * @return {string} commit sha
         */
        this.getCommitSha = (context) => utils_1.isPrRef(context) && context.payload.pull_request ? context.payload.pull_request.head.sha : context.sha;
        /**
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<Response<GitGetCommitResponse>>} commit
         */
        this.getCommit = (octokit, context) => __awaiter(this, void 0, void 0, function* () {
            return octokit.git.getCommit({
                owner: context.repo.owner,
                repo: context.repo.repo,
                'commit_sha': this.getCommitSha(context),
            });
        });
        /**
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<Response<PullsGetResponse>>} commit
         */
        this.getPR = (octokit, context) => __awaiter(this, void 0, void 0, function* () {
            const key = parseInt(context.payload.number, 10);
            if (!(key in this.prCache)) {
                this.prCache[key] = yield octokit.pulls.get({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    'pull_number': context.payload.number,
                });
            }
            return this.prCache[key];
        });
        /**
         * @param {string} rootDir root dir
         * @param {object} files files
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<{ path: string, sha: string }[]>} blobs
         */
        this.filesToBlobs = (rootDir, files, octokit, context) => __awaiter(this, void 0, void 0, function* () { return yield Promise.all(Object.values(files).map(file => this.createBlob(rootDir, file, octokit, context))); });
        /**
         * @param {{ path: string, sha: string }[]} blobs blobs
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<Response<GitCreateTreeResponse>>} tree
         */
        this.createTree = (blobs, octokit, context) => __awaiter(this, void 0, void 0, function* () {
            return octokit.git.createTree({
                owner: context.repo.owner,
                repo: context.repo.repo,
                'base_tree': (yield this.getCommit(octokit, context)).data.tree.sha,
                tree: Object.values(blobs).map(blob => ({
                    path: blob.path,
                    type: 'blob',
                    mode: '100644',
                    sha: blob.sha,
                })),
            });
        });
        /**
         * @param {string} commitMessage commit message
         * @param {Response<GitCreateTreeResponse>} tree tree
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<Response<GitCreateCommitResponse>>} commit
         */
        this.createCommit = (commitMessage, tree, octokit, context) => __awaiter(this, void 0, void 0, function* () {
            return octokit.git.createCommit({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tree: tree.data.sha,
                parents: [this.getCommitSha(context)],
                message: commitMessage,
            });
        });
        /**
         * @param {string} refName refName
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<AnyResponse|null>} refName
         */
        this.getRef = (refName, octokit, context) => __awaiter(this, void 0, void 0, function* () {
            try {
                return yield octokit.git.getRef({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: refName,
                });
            }
            catch (error) {
                return null;
            }
        });
        /**
         * @param {Response<GitCreateCommitResponse>} commit commit
         * @param {string} refName refName
         * @param {boolean} force force
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<void>} void
         */
        this.updateRef = (commit, refName, force, octokit, context) => __awaiter(this, void 0, void 0, function* () {
            try {
                yield octokit.git.updateRef({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: refName,
                    sha: commit.data.sha,
                    force,
                });
                return true;
            }
            catch (error) {
                if (this.suppressBPError === true && this.isProtectedBranchError(error)) {
                    this.logger.warn('Branch is protected.');
                }
                else {
                    throw error;
                }
                return false;
            }
        });
        /**
         * @param {Response<GitCreateCommitResponse>} commit commit
         * @param {string} refName refName
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<void>} void
         */
        this.createRef = (commit, refName, octokit, context) => __awaiter(this, void 0, void 0, function* () {
            yield octokit.git.createRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: refName,
                sha: commit.data.sha,
            });
        });
        /**
         * @param {string} refName refName
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<void>} void
         */
        this.deleteRef = (refName, octokit, context) => __awaiter(this, void 0, void 0, function* () {
            yield octokit.git.deleteRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: refName,
            });
        });
        /**
         * @param {string} branchName branch name
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<PullsListResponseItem>} pull request
         */
        this.findPullRequest = (branchName, octokit, context) => __awaiter(this, void 0, void 0, function* () {
            const response = yield octokit.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head: `${context.repo.owner}:${utils_1.getBranch(branchName, false)}`,
            });
            if (response.data.length) {
                return response.data[0];
            }
            return null;
        });
        /**
         * @param {string} branchName branch name
         * @param {PullsCreateParams} detail detail
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<PullsCreateResponse>} pull
         */
        this.pullsCreate = (branchName, detail, octokit, context) => __awaiter(this, void 0, void 0, function* () {
            return octokit.pulls.create(Object.assign({ owner: context.repo.owner, repo: context.repo.repo, head: `${context.repo.owner}:${utils_1.getBranch(branchName, false)}`, base: (yield this.getRefForUpdate(false, octokit, context)).replace(/^heads\//, '') }, detail));
        });
        /**
         * @param {number} number pull number
         * @param {PullsUpdateParams} detail detail
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<PullsUpdateResponse>} pull
         */
        this.pullsUpdate = (number, detail, octokit, context) => __awaiter(this, void 0, void 0, function* () {
            return octokit.pulls.update(Object.assign({ owner: context.repo.owner, repo: context.repo.repo, 'pull_number': number, base: (yield this.getRefForUpdate(false, octokit, context)).replace(/^heads\//, ''), state: 'open' }, detail));
        });
        /**
         * @param {string} branch branch
         * @return {object} branch info
         */
        this.getBranchInfo = (branch) => {
            const branchName = utils_1.getBranch(branch, false);
            const headName = `heads/${branchName}`;
            const refName = `refs/${headName}`;
            return { branchName, headName, refName };
        };
        /**
         * @param {string} createBranchName branch name
         * @param {PullsCreateParams} detail detail
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<PullsInfo>} info
         */
        this.pullsCreateOrUpdate = (createBranchName, detail, octokit, context) => __awaiter(this, void 0, void 0, function* () {
            const pullRequest = yield this.findPullRequest(createBranchName, octokit, context);
            if (pullRequest) {
                this.logger.startProcess('Updating PullRequest... [%s] -> [%s]', utils_1.getBranch(createBranchName, false), yield this.getRefForUpdate(false, octokit, context));
                const updated = yield this.pullsUpdate(pullRequest.number, detail, octokit, context);
                this.logger.endProcess();
                return Object.assign({ isPrCreated: false }, updated.data);
            }
            else {
                this.logger.startProcess('Creating PullRequest... [%s] -> [%s]', utils_1.getBranch(createBranchName, false), yield this.getRefForUpdate(false, octokit, context));
                const created = yield this.pullsCreate(createBranchName, detail, octokit, context);
                this.logger.endProcess();
                return Object.assign({ isPrCreated: true }, created.data);
            }
        });
        /**
         * @param {string} createBranchName branch name
         * @param {PullsCreateParams} detail detail
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<PullsInfo>} info
         */
        this.pullsCreateOrComment = (createBranchName, detail, octokit, context) => __awaiter(this, void 0, void 0, function* () {
            const pullRequest = yield this.findPullRequest(createBranchName, octokit, context);
            if (pullRequest) {
                this.logger.startProcess('Creating comment to PullRequest... [%s] -> [%s]', utils_1.getBranch(createBranchName, false), yield this.getRefForUpdate(false, octokit, context));
                yield this.createCommentToPr(createBranchName, detail.body, octokit, context);
                this.logger.endProcess();
                return Object.assign({ isPrCreated: false }, pullRequest);
            }
            else {
                this.logger.startProcess('Creating PullRequest... [%s] -> [%s]', utils_1.getBranch(createBranchName, false), yield this.getRefForUpdate(false, octokit, context));
                const created = yield this.pullsCreate(createBranchName, detail, octokit, context);
                this.logger.endProcess();
                return Object.assign({ isPrCreated: true }, created.data);
            }
        });
        /**
         * @param {string} branch branch
         * @param {string} body body
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<boolean>} result
         */
        this.createCommentToPr = (branch, body, octokit, context) => __awaiter(this, void 0, void 0, function* () {
            if (!body) {
                return false;
            }
            const pullRequest = yield this.findPullRequest(branch, octokit, context);
            if (!pullRequest) {
                return false;
            }
            yield octokit.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                'issue_number': pullRequest.number,
                body,
            });
            return true;
        });
        /**
         * @param {Error} error error
         * @return {boolean} result
         */
        this.isProtectedBranchError = (error) => /required status checks?.* (is|are) expected/i.test(error.message);
        /**
         * @param {string[]} files files
         * @return {boolean} diff?
         */
        this.checkDiff = (files) => {
            if (!files.length) {
                this.logger.info('There is no diff.');
                return false;
            }
            return true;
        };
        /**
         * @param {string} rootDir root dir
         * @param {string} commitMessage commit message
         * @param {string[]} files files
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<Response<GitCreateCommitResponse>>} commit
         */
        this.prepareCommit = (rootDir, commitMessage, files, octokit, context) => __awaiter(this, void 0, void 0, function* () {
            this.logger.startProcess('Creating blobs...');
            const blobs = yield this.filesToBlobs(rootDir, files, octokit, context);
            this.logger.startProcess('Creating tree...');
            const tree = yield this.createTree(blobs, octokit, context);
            this.logger.startProcess('Creating commit... [%s]', tree.data.sha);
            return this.createCommit(commitMessage, tree, octokit, context);
        });
        /**
         * @param {string} rootDir root dir
         * @param {string} commitMessage commit message
         * @param {string[]} files files
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<boolean>} result
         */
        this.commit = (rootDir, commitMessage, files, octokit, context) => __awaiter(this, void 0, void 0, function* () {
            if (!this.checkDiff(files)) {
                return false;
            }
            const commit = yield this.prepareCommit(rootDir, commitMessage, files, octokit, context);
            const ref = yield this.getRefForUpdate(true, octokit, context);
            this.logger.startProcess('Updating ref... [%s] [%s]', ref, commit.data.sha);
            if (yield this.updateRef(commit, ref, false, octokit, context)) {
                process.env.GITHUB_SHA = commit.data.sha;
                core_1.exportVariable('GITHUB_SHA', commit.data.sha);
            }
            this.logger.endProcess();
            return true;
        });
        /**
         * @param {string} rootDir root dir
         * @param {string} commitMessage commit message
         * @param {string[]} files files
         * @param {string} createBranchName branch name
         * @param {PullsCreateParams} detail detail
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<boolean|PullsInfo>} result
         */
        this.createPR = (rootDir, commitMessage, files, createBranchName, detail, octokit, context) => __awaiter(this, void 0, void 0, function* () {
            if (!this.checkDiff(files)) {
                return false;
            }
            const { branchName, headName, refName } = this.getBranchInfo(createBranchName);
            const commit = yield this.prepareCommit(rootDir, commitMessage, files, octokit, context);
            const ref = yield this.getRef(headName, octokit, context);
            if (null === ref) {
                this.logger.startProcess('Creating reference... [%s] [%s]', refName, commit.data.sha);
                yield this.createRef(commit, refName, octokit, context);
            }
            else {
                this.logger.startProcess('Updating reference... [%s] [%s]', refName, commit.data.sha);
                yield this.updateRef(commit, headName, true, octokit, context);
            }
            return this.pullsCreateOrUpdate(branchName, detail, octokit, context);
        });
        /**
         * @param {string} createBranchName branch name
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @param {string} message message
         */
        this.closePR = (createBranchName, octokit, context, message) => __awaiter(this, void 0, void 0, function* () {
            const { branchName, headName, refName } = this.getBranchInfo(createBranchName);
            const pullRequest = yield this.findPullRequest(branchName, octokit, context);
            if (pullRequest) {
                this.logger.startProcess('Closing PullRequest... [%s]', branchName);
                if (message) {
                    yield this.createCommentToPr(branchName, message, octokit, context);
                }
                yield this.pullsUpdate(pullRequest.number, {
                    state: 'closed',
                    base: undefined,
                }, octokit, context);
            }
            else {
                this.logger.info('There is no PullRequest named [%s]', branchName);
                const ref = yield this.getRef(headName, octokit, context);
                if (!ref) {
                    this.logger.info('There is no reference named [%s]', refName);
                    return;
                }
            }
            this.logger.startProcess('Deleting reference... [%s]', refName);
            yield this.deleteRef(headName, octokit, context);
            this.logger.endProcess();
        });
        /**
         * @param {GitHub} octokit octokit
         * @param {Context} context context
         * @return {Promise<{ login: string, email: string, name: string, id: number }>} user
         */
        this.getUser = (octokit, context) => __awaiter(this, void 0, void 0, function* () {
            const sender = this.getSender(context);
            if (false === sender) {
                throw new Error('Sender is not valid.');
            }
            const { data: user } = yield octokit.users.getByUsername({
                username: sender,
            });
            return {
                login: user.login,
                email: user.email,
                name: user.name,
                id: user.id,
            };
        });
        if (options) {
            this.branch = options.branch;
            this.sender = options.sender;
            this.refForUpdate = options.refForUpdate;
            this.suppressBPError = options.suppressBPError;
        }
    }
    /**
     * @param {PullsListParams} params params
     * @param {GitHub} octokit octokit
     * @param {Context} context context
     * @return {AsyncIterable<PullsListResponseItem>} pull request list
     */
    pullsList(params, octokit, context) {
        return __asyncGenerator(this, arguments, function* pullsList_1() {
            const perPage = 100;
            let page = 1;
            while (true) {
                const list = yield __await(octokit.pulls.list(Object.assign({
                    sort: 'created',
                    direction: 'asc',
                }, params, {
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    'per_page': perPage,
                    page: page++,
                })));
                if (!list.data.length) {
                    break;
                }
                for (const item of list.data) {
                    yield yield __await(item);
                }
            }
        });
    }
}
exports.default = ApiHelper;
//# sourceMappingURL=api-helper.js.map