"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const index_1 = require("./index");
const utils_1 = require("./utils");
/**
 * Git Helper
 */
class GitHelper {
    /**
     * @param {Logger} logger logger
     * @param {object} options options
     * @param {number|undefined} options.depth depth
     * @param {function|undefined} options.filter filter
     */
    constructor(logger, options) {
        this.logger = logger;
        /**
         * @param {string} workDir work dir
         * @return {boolean} is cloned?
         */
        this.isCloned = (workDir) => fs_1.default.existsSync(path_1.default.resolve(workDir, '.git'));
        /**
         * @param {string} workDir work dir
         * @return {Promise<string>} branch name
         */
        this.getCurrentBranchName = (workDir) => __awaiter(this, void 0, void 0, function* () {
            if (!this.isCloned(workDir)) {
                return '';
            }
            return (yield this.command.execAsync({ command: `git -C ${workDir} branch -a | grep -E '^\\*' | cut -b 3-` })).trim();
        });
        /**
         * @param {string} workDir work dir
         * @param {string} branch branch
         * @param {Context} context context
         * @return {Promise<void>} void
         */
        this.cloneBranch = (workDir, branch, context) => __awaiter(this, void 0, void 0, function* () {
            const url = utils_1.getGitUrl(context);
            yield this.command.execAsync({
                command: `git -C ${workDir} clone --branch=${branch}${this.cloneDepth} ${url} .`,
                quiet: true,
                altCommand: `git clone --branch=${branch}${this.cloneDepth}`,
                suppressError: true,
            });
        });
        /**
         * @param {string} workDir work dir
         * @param {Context} context context
         * @return {Promise<void>} void
         */
        this.clonePR = (workDir, context) => __awaiter(this, void 0, void 0, function* () {
            const url = utils_1.getGitUrl(context);
            yield this.command.execAsync({
                command: `git -C ${workDir} clone${this.cloneDepth} ${url} .`,
                quiet: true,
                altCommand: `git clone${this.cloneDepth}`,
                suppressError: true,
            });
            yield this.command.execAsync({ command: `git -C ${workDir} fetch origin +${context.ref}` });
            yield this.command.execAsync({ command: `git -C ${workDir} checkout -qf FETCH_HEAD` });
        });
        /**
         * @param {string} workDir work dir
         * @param {Context} context context
         * @return {Promise<void>} void
         */
        this.clone = (workDir, context) => __awaiter(this, void 0, void 0, function* () {
            if (this.isCloned(workDir)) {
                return;
            }
            if (utils_1.isBranch(context)) {
                yield this.cloneBranch(workDir, utils_1.getBranch(context), context);
            }
            else if (utils_1.isPrRef(context)) {
                yield this.clonePR(workDir, context);
            }
            else {
                yield this.checkout(workDir, context);
            }
        });
        /**
         * @param {string} workDir work dir
         * @param {Context} context context
         * @return {Promise<void>} void
         */
        this.checkout = (workDir, context) => __awaiter(this, void 0, void 0, function* () {
            const url = utils_1.getGitUrl(context);
            if (this.cloneDepth && context.sha) {
                yield this.command.execAsync({ command: `git -C ${workDir} clone${this.cloneDepth} ${url} .`, quiet: true, altCommand: `git clone${this.cloneDepth}` });
                yield this.command.execAsync({ command: `git -C ${workDir} fetch ${url} ${context.ref}`, quiet: true, altCommand: `git fetch origin ${context.ref}` });
                yield this.command.execAsync({ command: `git -C ${workDir} checkout -qf ${context.sha}` });
            }
            else {
                const checkout = context.sha || utils_1.getBranch(context) || context.ref;
                if (!checkout) {
                    throw new Error('Invalid context.');
                }
                yield this.command.execAsync({ command: `git -C ${workDir} clone ${url} .`, quiet: true, altCommand: 'git clone' });
                yield this.command.execAsync({ command: `git -C ${workDir} checkout -qf ${checkout}` });
            }
        });
        /**
         * @param {string} workDir work dir
         * @param {string} branch branch
         * @return {Promise<void>} void
         */
        this.gitInit = (workDir, branch) => __awaiter(this, void 0, void 0, function* () {
            yield this.command.execAsync({ command: `rm -rdf ${workDir}` });
            fs_1.default.mkdirSync(workDir, { recursive: true });
            yield this.command.execAsync({ command: `git -C ${workDir} init .` });
            yield this.command.execAsync({ command: `git -C ${workDir} checkout --orphan "${branch}"` });
        });
        /**
         * @param {string} workDir work dir
         * @param {string} name name
         * @param {string} email email
         * @return {Promise<void>} void
         */
        this.config = (workDir, name, email) => __awaiter(this, void 0, void 0, function* () {
            yield this.command.execAsync({ command: `git -C ${workDir} config user.name "${name}"` });
            yield this.command.execAsync({ command: `git -C ${workDir} config user.email "${email}"` });
        });
        /**
         * @param {string} workDir work dir
         * @param {string[]} commands commands
         * @return {Promise<void>} void
         */
        this.runCommand = (workDir, commands) => __awaiter(this, void 0, void 0, function* () {
            for (const command of commands) {
                yield this.command.execAsync({ command, cwd: workDir });
            }
        });
        /**
         * @param {string} workDir work dir
         * @return {Promise<string[]>} diff
         */
        this.getDiff = (workDir) => __awaiter(this, void 0, void 0, function* () {
            return (yield this.command.execAsync({
                command: `git -C ${workDir} status --short -uno`,
                suppressOutput: true,
            }))
                .split(/\r\n|\n/)
                .filter(line => line.match(/^[MDA]\s+/))
                .filter(this.filter)
                .map(line => line.replace(/^[MDA]\s+/, ''));
        });
        /**
         * @param {string} workDir work dir
         * @return {Promise<boolean>} result
         */
        this.checkDiff = (workDir) => __awaiter(this, void 0, void 0, function* () { return !!(yield this.getDiff(workDir)).length; });
        /**
         * @param {string} workDir work dir
         * @param {string} message message
         */
        this.commit = (workDir, message) => __awaiter(this, void 0, void 0, function* () {
            yield this.command.execAsync({ command: `git -C ${workDir} add --all` });
            if (!(yield this.checkDiff(workDir))) {
                this.logger.info('There is no diff.');
                return false;
            }
            yield this.command.execAsync({ command: `git -C ${workDir} commit -qm "${message.replace('"', '\\"')}"` });
            yield this.command.execAsync({ command: `git -C ${workDir} show --stat-count=10 HEAD` });
            return true;
        });
        /**
         * @param {string} workDir work dir
         * @param {Context} context context
         * @return {Promise<void>} void
         */
        this.fetchTags = (workDir, context) => __awaiter(this, void 0, void 0, function* () {
            const url = utils_1.getGitUrl(context);
            yield this.command.execAsync({ command: `git -C ${workDir} tag -l | xargs git -C ${workDir} tag -d` });
            yield this.command.execAsync({ command: `git -C ${workDir} fetch "${url}" --tags`, quiet: true, altCommand: 'git fetch origin --tags' });
        });
        /**
         * @param {string} workDir work dir
         * @param {string|string[]} tags tags
         * @param {Context} context context
         * @return {Promise<void>} void
         */
        this.deleteTag = (workDir, tags, context) => __awaiter(this, void 0, void 0, function* () {
            if ('string' === typeof tags) {
                const url = utils_1.getGitUrl(context);
                yield this.command.execAsync({
                    command: `git -C ${workDir} push --delete "${url}" tag ${tags}`,
                    quiet: true,
                    altCommand: `git push --delete origin tag ${tags}`,
                    suppressError: true,
                });
            }
            else {
                for (const tag of tags) {
                    yield this.deleteTag(workDir, tag, context);
                }
            }
        });
        /**
         * @param {string} workDir work dir
         * @param {string} newTag new tag
         * @param {string} fromTag from tag
         * @param {Context} context context
         * @return {Promise<void>} void
         */
        this.copyTag = (workDir, newTag, fromTag, context) => __awaiter(this, void 0, void 0, function* () {
            const url = utils_1.getGitUrl(context);
            yield this.deleteTag(workDir, newTag, context);
            yield this.command.execAsync({ command: `git -C ${workDir} tag ${newTag} ${fromTag}` });
            yield this.command.execAsync({
                command: `git -C ${workDir} push "${url}" "refs/tags/${newTag}"`,
                quiet: true,
                altCommand: `git push "refs/tags/${newTag}"`,
            });
        });
        /**
         * @param {string} workDir work dir
         * @param {string|string[]} tags tags
         * @return {Promise<void>} void
         */
        this.addLocalTag = (workDir, tags) => __awaiter(this, void 0, void 0, function* () {
            if ('string' === typeof tags) {
                yield this.command.execAsync({ command: `git -C ${workDir} tag ${tags}` });
            }
            else {
                for (const tag of tags) {
                    yield this.addLocalTag(workDir, tag);
                }
            }
        });
        /**
         * @param {string} workDir work dir
         * @param {string} branch branch
         * @param {Context} context context
         * @return {Promise<void>} void
         */
        this.push = (workDir, branch, context) => __awaiter(this, void 0, void 0, function* () {
            const url = utils_1.getGitUrl(context);
            yield this.command.execAsync({
                command: `git -C ${workDir} push --tags "${url}" "${branch}":"refs/heads/${branch}"`,
                quiet: true,
                altCommand: `git push --tags "${branch}":"refs/heads/${branch}"`,
            });
        });
        this.command = new index_1.Command(logger);
        if (options && options.depth) {
            this.cloneDepth = options.depth > 0 ? ` --depth=${options.depth}` : ''; // eslint-disable-line no-magic-numbers
        }
        else {
            this.cloneDepth = ' --depth=3';
        }
        if (options && options.filter) {
            this.filter = options.filter;
        }
        else {
            this.filter = (line) => !!line.trim();
        }
    }
}
exports.default = GitHelper;
//# sourceMappingURL=git-helper.js.map