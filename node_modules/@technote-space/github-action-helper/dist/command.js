"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
/**
 * Command
 */
class Command {
    /**
     * @param {Logger} logger logger
     */
    constructor(logger) {
        this.logger = logger;
        /**
         * @param {string} command command
         * @param {boolean} quiet quiet?
         * @param {boolean} suppressError suppress error?
         * @return {string} command
         */
        this.getCommand = (command, quiet, suppressError) => command + (quiet ? ' > /dev/null 2>&1' : '') + (suppressError ? ' || :' : '');
        /**
         * @param {string} command command
         * @param {string} altCommand alt command
         * @param {boolean} quiet quiet?
         * @param {ExecException} error error
         * @return {string} message
         */
        this.getRejectedErrorMessage = (command, altCommand, quiet, error) => {
            if ('string' === typeof altCommand) {
                if (!quiet) {
                    return `command [${altCommand}] exited with code ${error.code}. message: ${error.message}`;
                }
                else {
                    return `command [${altCommand}] exited with code ${error.code}.`;
                }
            }
            else if (!quiet) {
                return `command [${command}] exited with code ${error.code}. message: ${error.message}`;
            }
            return `command exited with code ${error.code}.`;
        };
        /**
         * @param {string} command command
         * @param {string|undefined} altCommand alt command
         * @param {boolean} quiet quiet?
         * @param {boolean} suppressOutput suppress output?
         * @param {boolean} stderrToStdout output to stdout instead of stderr
         * @param {function} resolve resolve
         * @param {function} reject reject
         * @return {void} void
         */
        this.execCallback = (command, altCommand, quiet, suppressOutput, stderrToStdout, resolve, reject) => (error, stdout, stderr) => {
            if (error) {
                reject(this.getRejectedErrorMessage(command, altCommand, quiet, error));
            }
            else {
                let trimmedStdout = stdout.trim();
                let trimmedStderr = stderr.trim();
                if (!quiet && !suppressOutput) {
                    if (trimmedStdout) {
                        this.logger.displayStdout(trimmedStdout);
                    }
                    if (trimmedStderr) {
                        if (stderrToStdout) {
                            this.logger.displayStdout(trimmedStderr);
                            trimmedStdout += `\n${trimmedStderr}`;
                            trimmedStderr = '';
                        }
                        else {
                            this.logger.displayStderr(trimmedStderr);
                        }
                    }
                }
                resolve({ stdout: trimmedStdout, stderr: trimmedStderr });
            }
        };
        /**
         * @param {object} args args
         * @param {string} args.command command
         * @param {string|undefined} args.cwd cwd
         * @param {boolean|undefined} args.quiet quiet?
         * @param {string|undefined} args.altCommand alt command
         * @param {boolean|undefined} args.suppressError suppress error?
         * @param {boolean|undefined} args.suppressOutput suppress output?
         * @param {boolean|undefined} args.stderrToStdout output to stdout instead of stderr
         * @return {Promise<object>} output
         */
        this.execAsync = (args) => new Promise((resolve, reject) => {
            const { command, cwd, altCommand, quiet = false, suppressError = false, suppressOutput = false, stderrToStdout = false } = args;
            if (undefined !== altCommand) {
                this.logger.displayCommand(altCommand);
            }
            else if (!quiet) {
                this.logger.displayCommand(command);
            }
            if (typeof cwd === 'undefined') {
                child_process_1.exec(this.getCommand(command, quiet, suppressError), this.execCallback(command, altCommand, quiet, suppressOutput, stderrToStdout, resolve, reject));
            }
            else {
                child_process_1.exec(this.getCommand(command, quiet, suppressError), { cwd }, this.execCallback(command, altCommand, quiet, suppressOutput, stderrToStdout, resolve, reject));
            }
        });
    }
}
exports.default = Command;
//# sourceMappingURL=command.js.map