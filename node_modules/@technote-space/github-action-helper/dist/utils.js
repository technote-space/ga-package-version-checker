"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const core_1 = require("@actions/core");
exports.getBuildVersion = (filepath) => {
    if (!fs_1.default.existsSync(filepath)) {
        return false;
    }
    const json = JSON.parse(fs_1.default.readFileSync(filepath, 'utf8'));
    if (json && 'tagName' in json) {
        return json['tagName'];
    }
    return false;
};
exports.isRelease = (context) => 'release' === context.eventName;
exports.getTagName = (context) => exports.isRelease(context) ? context.payload.release.tag_name : (/^refs\/tags\//.test(context.ref) ? context.ref.replace(/^refs\/tags\//, '') : '');
exports.isSemanticVersioningTagName = (tagName) => /^v?\d+(\.\d+)*$/i.test(tagName);
exports.isBranch = (context) => /^refs\/heads\//.test(context.ref);
exports.isRemoteBranch = (context) => /^refs\/remotes\/origin\//.test(context.ref);
exports.isPrRef = (context) => /^refs\/pull\/\d+\/(merge|head)$/.test(context.ref);
exports.getPrMergeRef = (context) => context.ref.replace(/^refs\/pull\/(\d+)\/(merge|head)$/, 'refs/pull/$1/merge');
exports.getPrHeadRef = (context) => context.ref.replace(/^refs\/pull\/(\d+)\/(merge|head)$/, 'refs/pull/$1/head');
exports.getBranch = (context) => exports.isBranch(context) ?
    context.ref.replace(/^refs\/heads\//, '') :
    (exports.isRemoteBranch(context) ? context.ref.replace(/^refs\/remotes\/origin\//, '') : '');
exports.getRefForUpdate = (context) => context.ref.replace(/^refs\//, '');
exports.getSender = (context) => context.payload.sender && context.payload.sender.type === 'User' ? context.payload.sender.login : false;
exports.getRepository = (context) => `${context.repo.owner}/${context.repo.repo}`;
const getAccessToken = (required) => core_1.getInput('GITHUB_TOKEN', { required });
exports.getActor = () => process.env.GITHUB_ACTOR || '';
exports.getGitUrl = (context, accessTokenRequired = true) => {
    const token = getAccessToken(accessTokenRequired);
    if (token) {
        return `https://${exports.getActor()}:${token}@github.com/${context.repo.owner}/${context.repo.repo}.git`;
    }
    else {
        return `https://github.com/${context.repo.owner}/${context.repo.repo}.git`;
    }
};
exports.escapeRegExp = (text) => text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
exports.getBoolValue = (input) => !['false', '0', ''].includes(input.trim().toLowerCase());
exports.uniqueArray = (array) => [...new Set(array)];
exports.getWorkspace = () => process.env.GITHUB_WORKSPACE || '';
exports.showActionInfo = (rootDir, logger, context) => {
    const version = exports.getBuildVersion(path_1.default.resolve(rootDir, 'build.json'));
    const tagName = exports.getTagName(context);
    logger.log('');
    logger.log('==================================================');
    if ('string' === typeof version) {
        logger.log('Version:  %s', version);
    }
    logger.log('Event:    %s', context.eventName);
    logger.log('Action:   %s', context.payload.action);
    logger.log('sha:      %s', context.sha);
    logger.log('ref:      %s', context.ref);
    if (tagName) {
        logger.log('Tag name: %s', tagName);
    }
    if (context.payload.issue) {
        logger.log('Labels:');
        context.payload.issue.labels.map(label => label.name).forEach(label => logger.log('  - %s', label));
    }
    if (context.payload.pull_request) {
        logger.log('Labels:');
        context.payload.pull_request.labels.map(label => label.name).forEach(label => logger.log('  - %s', label));
    }
    logger.log('owner:    %s', context.repo.owner);
    logger.log('repo:     %s', context.repo.repo);
    logger.log('actor:    %s', context.actor);
    logger.log('==================================================');
    logger.log('');
};
exports.getArrayInput = (name, required = false, separator = ',') => exports.uniqueArray(core_1.getInput(name, { required }).split(/\r?\n/).reduce((acc, line) => acc.concat(separator ? line.split(separator) : line).filter(item => item).map(item => item.trim()), []));
//# sourceMappingURL=utils.js.map