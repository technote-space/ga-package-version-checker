"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const core_1 = require("@actions/core");
const getRef = (ref) => typeof ref === 'string' ? ref : ref.ref;
exports.getBuildInfo = (filepath) => {
    if (!fs_1.default.existsSync(filepath)) {
        return false;
    }
    try {
        return JSON.parse(fs_1.default.readFileSync(filepath, 'utf8'));
    }
    catch (_a) {
        return false;
    }
};
exports.isCloned = (workDir) => fs_1.default.existsSync(path_1.default.resolve(workDir, '.git'));
exports.isSemanticVersioningTagName = (tagName) => /^v?\d+(\.\d+)*$/i.test(tagName);
exports.isBranch = (ref) => /^(refs\/)?heads/.test(getRef(ref));
exports.isRemoteBranch = (ref) => /^(refs\/)?remotes\/origin\//.test(getRef(ref));
exports.isPrRef = (ref) => /^refs\/pull\/\d+\/(merge|head)$/.test(getRef(ref));
exports.getPrMergeRef = (ref) => getRef(ref).replace(/^refs\/pull\/(\d+)\/(merge|head)$/, 'refs/pull/$1/merge');
exports.getPrHeadRef = (ref) => getRef(ref).replace(/^refs\/pull\/(\d+)\/(merge|head)$/, 'refs/pull/$1/head');
exports.getRefForUpdate = (ref) => getRef(ref).replace(/^refs\//, '');
exports.getBranch = (ref, defaultIsEmpty = true) => exports.isBranch(ref) ?
    getRef(ref).replace(/^(refs\/)?heads\//, '') :
    (exports.isRemoteBranch(ref) ? getRef(ref).replace(/^(refs\/)?remotes\/origin\//, '') :
        (defaultIsEmpty ? '' : exports.getRefForUpdate(ref)));
exports.getAccessToken = (required) => core_1.getInput('GITHUB_TOKEN', { required });
exports.getActor = () => process.env.GITHUB_ACTOR || '';
exports.escapeRegExp = (text) => text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
exports.getRegExp = (value) => new RegExp(exports.escapeRegExp(value));
exports.getPrefixRegExp = (value) => new RegExp('^' + exports.escapeRegExp(value));
exports.getSuffixRegExp = (value) => new RegExp(exports.escapeRegExp(value) + '$');
exports.getBoolValue = (input) => !['false', '0', ''].includes(input.trim().toLowerCase());
exports.uniqueArray = (array) => [...new Set(array)];
exports.getWorkspace = () => process.env.GITHUB_WORKSPACE || '';
exports.split = (value, separator = /\r?\n/, limit) => value.length ? value.split(separator, limit) : [];
exports.getArrayInput = (name, required = false, separator = ',') => exports.uniqueArray(core_1.getInput(name, { required }).split(/\r?\n/).reduce((acc, line) => acc.concat(separator ? line.split(separator) : line).filter(item => item).map(item => item.trim()), []));
exports.sleep = (millisecond) => __awaiter(void 0, void 0, void 0, function* () { return new Promise(resolve => setTimeout(resolve, millisecond)); });
exports.useNpm = (workDir, pkgManager = '') => 'npm' === pkgManager ||
    ('yarn' !== pkgManager && (fs_1.default.existsSync(path_1.default.resolve(workDir, 'package-lock.json')) ||
        !fs_1.default.existsSync(path_1.default.resolve(workDir, 'yarn.lock'))));
exports.replaceAll = (string, key, value) => string.split(key).join(value);
//# sourceMappingURL=utils.js.map